Class,Method Name,Arg/Ret/Var,Variable Name,Inferred Type,Original Type,Exact (E) / Up to Parameter (P) / Got Type (T) / None (N),Solution Source,Source Code
Money::Currency::MissingAttributeError,initialize,Ret,"",self,self,E,,"def initialize(method, currency, attribute)
        super(
          ""Can't call Currency.#{method} - currency '#{currency}' is missing ""\
          ""the attribute '#{attribute}'""
        )
      end"
[s]Money::Currency,find,Arg,id,[ to_s: () -> String ],(String or Symbol or [ to_s: (String) -> String ]),TS,Constraints,"def find(id)
        id = id.to_s.downcase.to_sym
        new(id)
      rescue UnknownCurrency
        nil
      end"
[s]Money::Currency,find,Ret,"",nil,Money::Currency,T,Constraints,"def find(id)
        id = id.to_s.downcase.to_sym
        new(id)
      rescue UnknownCurrency
        nil
      end"
[s]Money::Currency,find_by_iso_numeric,Arg,num,String,[ to_s: (String) -> String ],T,Twin,"def find_by_iso_numeric(num)
        num = num.to_s.rjust(3, '0')
        return if num.empty?
        id, _ = self.table.find { |key, currency| currency[:iso_numeric] == num }
        new(id)
      rescue UnknownCurrency
        nil
      end"
[s]Money::Currency,find_by_iso_numeric,Ret,"",nil,Money::Currency,T,Constraints,"def find_by_iso_numeric(num)
        num = num.to_s.rjust(3, '0')
        return if num.empty?
        id, _ = self.table.find { |key, currency| currency[:iso_numeric] == num }
        new(id)
      rescue UnknownCurrency
        nil
      end"
[s]Money::Currency,wrap,Arg,object,([ is_a?: (Class) -> { { [s]Money::Currency#wrap arg: object }#is_a? call_ret: ret } ] and [ nil?: () -> { { [s]Money::Currency#wrap arg: object }#nil? call_ret: ret } ]),Object,TS,Constraints,"def wrap(object)
        if object.nil?
          nil
        elsif object.is_a?(Currency)
          RDL.type_cast(object, ""Money::Currency"")
        else
          Currency.new(RDL.type_cast(object, ""String or Symbol""))
        end
      end"
[s]Money::Currency,wrap,Ret,"",Money::Currency,Money::Currency,E,Constraints,"def wrap(object)
        if object.nil?
          nil
        elsif object.is_a?(Currency)
          RDL.type_cast(object, ""Money::Currency"")
        else
          Currency.new(RDL.type_cast(object, ""String or Symbol""))
        end
      end"
[s]Money::Currency,all,Ret,"",{ [s]Money::Currency#all ret: ret },Array,N,,"def all
        table.keys.map do |curr|
          c = Currency.new(curr)
          if c.priority.nil?
            raise MissingAttributeError.new(:all, c.id, :priority)
          end
          c
        end.sort_by(&:priority)
      end"
[s]Money::Currency,stringified_keys,Ret,"","Hash<{ Money::RatesStore::Memory#initialize hash_param_key: hash_param_key_#<Parser::Source::Map::Collection:0x00007fd987943258> }, { Money::RatesStore::Memory#initialize hash_param_val: hash_param_val_#<Parser::Source::Map::Collection:0x00007fd987943258> }>",Set,T,Constraints,"def stringified_keys
        @stringified_keys ||= stringify_keys
      end"
[s]Money::Currency,register,Arg,curr,[ fetch: (:iso_code) -> { { [s]Money::Currency#register arg: curr }#fetch call_ret: ret } ],Hash,TS,Constraints,"def register(curr)
        key = curr.fetch(:iso_code).downcase.to_sym
        @@mutex.synchronize { _instances.delete(key.to_s) }
        @table[key] = curr
        @stringified_keys = nil
      end"
[s]Money::Currency,inherit,Arg,parent_iso_code,[ downcase: () -> { { [s]Money::Currency#inherit arg: parent_iso_code }#downcase call_ret: ret } ],String,TS,Constraints,"def inherit(parent_iso_code, curr)
        parent_iso_code = parent_iso_code.downcase.to_sym
        curr = @table.fetch(parent_iso_code, {}).merge(curr)
        register(curr)
      end"
[s]Money::Currency,inherit,Arg,curr,[ fetch: (:iso_code) -> { { [s]Money::Currency#register arg: curr }#fetch call_ret: ret } ],Hash,TS,Constraints,"def inherit(parent_iso_code, curr)
        parent_iso_code = parent_iso_code.downcase.to_sym
        curr = @table.fetch(parent_iso_code, {}).merge(curr)
        register(curr)
      end"
[s]Money::Currency,unregister,Arg,curr,([ fetch: (:iso_code) -> { { [s]Money::Currency#unregister arg: curr }#fetch call_ret: ret } ] and [ is_a?: (Class) -> { { [s]Money::Currency#unregister arg: curr }#is_a? call_ret: ret } ]),Object,TS,Constraints,"def unregister(curr)
        if curr.is_a?(Hash)
          key = curr.fetch(:iso_code).downcase.to_sym
        else
          key = RDL.type_cast(curr, ""String or Symbol"").downcase.to_sym
        end
        existed = @table.delete(key)
        @stringified_keys = nil if existed
        existed ? true : false
      end"
[s]Money::Currency,unregister,Ret,"",(false or true),(false or true),E,Constraints,"def unregister(curr)
        if curr.is_a?(Hash)
          key = curr.fetch(:iso_code).downcase.to_sym
        else
          key = RDL.type_cast(curr, ""String or Symbol"").downcase.to_sym
        end
        existed = @table.delete(key)
        @stringified_keys = nil if existed
        existed ? true : false
      end"
Money::Currency,initialize,Arg,id,[ to_sym: () -> { { Money::Currency#initialize arg: id }#to_sym call_ret: ret } ],(String or Symbol or [ to_s: (String) -> String ]),TS,Constraints,"def initialize(id)
      @id = id.to_sym
      initialize_data!
    end"
Money::Currency,initialize,Ret,"",self,self,E,,"def initialize(id)
      @id = id.to_sym
      initialize_data!
    end"
Money::Currency,<=>,Arg,other_currency,([ id: () -> { { Money::Currency#<=> arg: other_currency }#id call_ret: ret } ] and [ priority: () -> { { Money::Currency#<=> arg: other_currency }#priority call_ret: ret } ]),Money::Currency,TS,Constraints,"def <=>(other_currency)
      # <=> returns nil when one of the values is nil
      comparison = self.priority <=> other_currency.priority || 0

      if comparison == 0
        self.id <=> other_currency.id
      else
        comparison
      end
    end"
Money::Currency,<=>,Ret,"",Number,Number,E,Constraints,"def <=>(other_currency)
      # <=> returns nil when one of the values is nil
      comparison = self.priority <=> other_currency.priority || 0

      if comparison == 0
        self.id <=> other_currency.id
      else
        comparison
      end
    end"
Money::Currency,==,Arg,other_currency,([ id: () -> { { Money::Currency#compare_ids arg: other_currency }#id call_ret: ret } ] and [ is_a?: (Class) -> { { Money::Currency#compare_ids arg: other_currency }#is_a? call_ret: ret } ] and [ to_s: () -> String ]),Money::Currency,TS,Constraints,"def ==(other_currency)
      self.equal?(other_currency) || compare_ids(other_currency)
    end"
Money::Currency,==,Ret,"",(false or true),(false or true),E,Constraints,"def ==(other_currency)
      self.equal?(other_currency) || compare_ids(other_currency)
    end"
Money::Currency,hash,Ret,"",Number,Number,E,Twin,"def hash
      id.hash
    end"
Money::Currency,to_s,Ret,"",String,String,E,Constraints,"def to_s
      id.to_s.upcase
    end"
Money::Currency,to_str,Ret,"",String,String,E,Constraints,"def to_str
      id.to_s.upcase
    end"
Money::Currency,to_sym,Ret,"",Symbol,Symbol,E,Constraints,"def to_sym
      id.to_s.upcase.to_sym
    end"
Money::Currency,to_currency,Ret,"",Money::Currency,Money::Currency,E,Constraints,"def to_currency
      self
    end"
Money::Currency,code,Ret,"",{ Money::Currency#code ret: ret },String,N,,"def code
      symbol || iso_code
    end"
Money::Currency,symbol_first?,Ret,"",(false or true),(false or true),E,Constraints,"def symbol_first?
      !!@symbol_first
    end"
Money::Currency,iso?,Ret,"",{ Money::Currency#iso? ret: ret },(false or true),N,,"def iso?
      iso_numeric && iso_numeric != ''
    end"
Money::Currency,exponent,Ret,"",Number,Number,E,Constraints,"def exponent
      Math.log10(subunit_to_unit).round
    end"
[s]Money,default_bank,Ret,"",{ [s]Money#default_bank ret: ret },Money::Bank::Base,N,,"def self.default_bank
    if @default_bank.respond_to?(:call)
      @default_bank.call
    else
      @default_bank
    end
  end"
[s]Money,use_i18n=,Ret,"",(false or true),(false or true),E,Constraints,"def self.use_i18n=(value)
    if value
      warn '[DEPRECATION] `use_i18n` is deprecated - use `Money.locale_backend = :i18n` instead for locale based formatting'
    else
      warn '[DEPRECATION] `use_i18n` is deprecated - use `Money.locale_backend = :currency` instead for currency based formatting'
    end

    @use_i18n = value
  end"
[s]Money,rounding_mode,Arg,mode,?String,Number,T,Constraints,"def self.rounding_mode(mode = nil)
    if mode
      warn ""[DEPRECATION] calling `rounding_mode` with a block is deprecated. Please use `.with_rounding_mode` instead.""
      return with_rounding_mode(mode) { yield }
    end

    return Thread.current[:money_rounding_mode] if Thread.current[:money_rounding_mode]

    if @using_deprecated_default_rounding_mode
      warn '[WARNING] The default rounding mode will change from `ROUND_HALF_EVEN` to `ROUND_HALF_UP` in the ' \
           'next major release. Set it explicitly using `Money.rounding_mode=` to avoid potential problems.'
      @using_deprecated_default_rounding_mode = false
    end

    @rounding_mode
  end"
[s]Money,rounding_mode,Ret,"",Number,Number,E,Constraints,"def self.rounding_mode(mode = nil)
    if mode
      warn ""[DEPRECATION] calling `rounding_mode` with a block is deprecated. Please use `.with_rounding_mode` instead.""
      return with_rounding_mode(mode) { yield }
    end

    return Thread.current[:money_rounding_mode] if Thread.current[:money_rounding_mode]

    if @using_deprecated_default_rounding_mode
      warn '[WARNING] The default rounding mode will change from `ROUND_HALF_EVEN` to `ROUND_HALF_UP` in the ' \
           'next major release. Set it explicitly using `Money.rounding_mode=` to avoid potential problems.'
      @using_deprecated_default_rounding_mode = false
    end

    @rounding_mode
  end"
[s]Money,with_rounding_mode,Arg,mode,String,Number,T,Twin,"def self.with_rounding_mode(mode)
    Thread.current[:money_rounding_mode] = mode
    yield
  ensure
    Thread.current[:money_rounding_mode] = nil
  end"
[s]Money,with_rounding_mode,Ret,"",{ [s]Money#with_rounding_mode ret: ret },Object,N,,"def self.with_rounding_mode(mode)
    Thread.current[:money_rounding_mode] = mode
    yield
  ensure
    Thread.current[:money_rounding_mode] = nil
  end"
[s]Money,add_rate,Arg,from_currency,Number,(Money::Currency or String or Symbol),T,Twin,"def self.add_rate(from_currency, to_currency, rate)
    RDL.type_cast(Money.default_bank.add_rate(from_currency, to_currency, rate), ""Float"")
  end"
[s]Money,add_rate,Arg,to_currency,Number,(Money::Currency or String or Symbol),T,Twin,"def self.add_rate(from_currency, to_currency, rate)
    RDL.type_cast(Money.default_bank.add_rate(from_currency, to_currency, rate), ""Float"")
  end"
[s]Money,add_rate,Arg,rate,Number,Number,E,Twin,"def self.add_rate(from_currency, to_currency, rate)
    RDL.type_cast(Money.default_bank.add_rate(from_currency, to_currency, rate), ""Float"")
  end"
[s]Money,add_rate,Ret,"",Number,Number,E,Constraints,"def self.add_rate(from_currency, to_currency, rate)
    RDL.type_cast(Money.default_bank.add_rate(from_currency, to_currency, rate), ""Float"")
  end"
[s]Money,from_amount,Arg,amount,[ to_d: () -> { { [s]Money#from_amount arg: amount }#to_d call_ret: ret } ],Number,TS,Constraints,"def self.from_amount(amount, currency = default_currency, options = {})
    raise ArgumentError, ""'amount' must be numeric"" unless Numeric === amount

    currency = Currency.wrap(currency) || Money.default_currency
    value = amount.to_d * currency.subunit_to_unit
    new(value, currency, options)
  end"
[s]Money,from_amount,Arg,currency,?([ is_a?: (Class) -> { { [s]Money::Currency#wrap arg: object }#is_a? call_ret: ret } ] and [ nil?: () -> { { [s]Money::Currency#wrap arg: object }#nil? call_ret: ret } ] and [ subunit_to_unit: () -> { { [s]Money#from_amount arg: currency }#subunit_to_unit call_ret: ret } ]),(Money::Currency or String or Symbol),TS,Constraints,"def self.from_amount(amount, currency = default_currency, options = {})
    raise ArgumentError, ""'amount' must be numeric"" unless Numeric === amount

    currency = Currency.wrap(currency) || Money.default_currency
    value = amount.to_d * currency.subunit_to_unit
    new(value, currency, options)
  end"
[s]Money,from_amount,Arg,options,"?Hash<:bank, { Money::RatesStore::Memory#initialize hash_param_val: hash_param_val_#<Parser::Source::Map::Collection:0x00007fd987943a78> }>",Hash,P,Constraints,"def self.from_amount(amount, currency = default_currency, options = {})
    raise ArgumentError, ""'amount' must be numeric"" unless Numeric === amount

    currency = Currency.wrap(currency) || Money.default_currency
    value = amount.to_d * currency.subunit_to_unit
    new(value, currency, options)
  end"
[s]Money,from_amount,Arg,,"",Hash,N,,"def self.from_amount(amount, currency = default_currency, options = {})
    raise ArgumentError, ""'amount' must be numeric"" unless Numeric === amount

    currency = Currency.wrap(currency) || Money.default_currency
    value = amount.to_d * currency.subunit_to_unit
    new(value, currency, options)
  end"
[s]Money,from_amount,Ret,"",Money,Money,E,Constraints,"def self.from_amount(amount, currency = default_currency, options = {})
    raise ArgumentError, ""'amount' must be numeric"" unless Numeric === amount

    currency = Currency.wrap(currency) || Money.default_currency
    value = amount.to_d * currency.subunit_to_unit
    new(value, currency, options)
  end"
Money,initialize,Arg,obj,([ is_a?: (Class) -> { { Money#as_d arg: num }#is_a? call_ret: ret } ] and [ respond_to?: (:bank) -> { { Money#initialize arg: obj }#respond_to? call_ret: ret } ] and [ respond_to?: (:currency) -> { { Money#initialize arg: obj }#respond_to? call_ret: ret } ] and [ respond_to?: (:fractional) -> { { Money#initialize arg: obj }#respond_to? call_ret: ret } ] and [ respond_to?: (:to_d) -> { { Money#as_d arg: num }#respond_to? call_ret: ret } ] and [ to_s: () -> String ]),Object,TS,Constraints,"def initialize( obj, currency = Money.default_currency, options = {})
    # For backwards compatability, if options is not a Hash, treat it as a bank parameter
    unless options.is_a?(Hash)
      options = { bank: RDL.type_cast(options, ""Money::Bank::VariableExchange"") }
    end

    @fractional = as_d(obj.respond_to?(:fractional) ? RDL.type_cast(obj, ""Money"").fractional : obj)
    @currency   = obj.respond_to?(:currency) ? RDL.type_cast(obj, ""Money"").currency : Currency.wrap(currency)
    @currency ||= Money.default_currency
    @bank       = obj.respond_to?(:bank) ? RDL.type_cast(obj, ""Money"").bank : RDL.type_cast(options[:bank], ""Money::Bank::VariableExchange"")
    @bank     ||= Money.default_bank

    # BigDecimal can be Infinity and NaN, money of that amount does not make sense
    raise ArgumentError, 'must be initialized with a finite value' unless @fractional.finite?
  end"
Money,initialize,Arg,currency,?([ is_a?: (Class) -> { { [s]Money::Currency#wrap arg: object }#is_a? call_ret: ret } ] and [ nil?: () -> { { [s]Money::Currency#wrap arg: object }#nil? call_ret: ret } ]),(Money::Currency or String or Symbol),TS,Constraints,"def initialize( obj, currency = Money.default_currency, options = {})
    # For backwards compatability, if options is not a Hash, treat it as a bank parameter
    unless options.is_a?(Hash)
      options = { bank: RDL.type_cast(options, ""Money::Bank::VariableExchange"") }
    end

    @fractional = as_d(obj.respond_to?(:fractional) ? RDL.type_cast(obj, ""Money"").fractional : obj)
    @currency   = obj.respond_to?(:currency) ? RDL.type_cast(obj, ""Money"").currency : Currency.wrap(currency)
    @currency ||= Money.default_currency
    @bank       = obj.respond_to?(:bank) ? RDL.type_cast(obj, ""Money"").bank : RDL.type_cast(options[:bank], ""Money::Bank::VariableExchange"")
    @bank     ||= Money.default_bank

    # BigDecimal can be Infinity and NaN, money of that amount does not make sense
    raise ArgumentError, 'must be initialized with a finite value' unless @fractional.finite?
  end"
Money,initialize,Arg,options,?([ []: (:bank) -> { { Money#initialize arg: options }#[] call_ret: ret } ] and [ is_a?: (Class) -> { { Money#initialize arg: options }#is_a? call_ret: ret } ]),Hash,TS,Constraints,"def initialize( obj, currency = Money.default_currency, options = {})
    # For backwards compatability, if options is not a Hash, treat it as a bank parameter
    unless options.is_a?(Hash)
      options = { bank: RDL.type_cast(options, ""Money::Bank::VariableExchange"") }
    end

    @fractional = as_d(obj.respond_to?(:fractional) ? RDL.type_cast(obj, ""Money"").fractional : obj)
    @currency   = obj.respond_to?(:currency) ? RDL.type_cast(obj, ""Money"").currency : Currency.wrap(currency)
    @currency ||= Money.default_currency
    @bank       = obj.respond_to?(:bank) ? RDL.type_cast(obj, ""Money"").bank : RDL.type_cast(options[:bank], ""Money::Bank::VariableExchange"")
    @bank     ||= Money.default_bank

    # BigDecimal can be Infinity and NaN, money of that amount does not make sense
    raise ArgumentError, 'must be initialized with a finite value' unless @fractional.finite?
  end"
Money,initialize,Arg,,"",Hash,N,,"def initialize( obj, currency = Money.default_currency, options = {})
    # For backwards compatability, if options is not a Hash, treat it as a bank parameter
    unless options.is_a?(Hash)
      options = { bank: RDL.type_cast(options, ""Money::Bank::VariableExchange"") }
    end

    @fractional = as_d(obj.respond_to?(:fractional) ? RDL.type_cast(obj, ""Money"").fractional : obj)
    @currency   = obj.respond_to?(:currency) ? RDL.type_cast(obj, ""Money"").currency : Currency.wrap(currency)
    @currency ||= Money.default_currency
    @bank       = obj.respond_to?(:bank) ? RDL.type_cast(obj, ""Money"").bank : RDL.type_cast(options[:bank], ""Money::Bank::VariableExchange"")
    @bank     ||= Money.default_bank

    # BigDecimal can be Infinity and NaN, money of that amount does not make sense
    raise ArgumentError, 'must be initialized with a finite value' unless @fractional.finite?
  end"
Money,initialize,Ret,"",self,self,E,,"def initialize( obj, currency = Money.default_currency, options = {})
    # For backwards compatability, if options is not a Hash, treat it as a bank parameter
    unless options.is_a?(Hash)
      options = { bank: RDL.type_cast(options, ""Money::Bank::VariableExchange"") }
    end

    @fractional = as_d(obj.respond_to?(:fractional) ? RDL.type_cast(obj, ""Money"").fractional : obj)
    @currency   = obj.respond_to?(:currency) ? RDL.type_cast(obj, ""Money"").currency : Currency.wrap(currency)
    @currency ||= Money.default_currency
    @bank       = obj.respond_to?(:bank) ? RDL.type_cast(obj, ""Money"").bank : RDL.type_cast(options[:bank], ""Money::Bank::VariableExchange"")
    @bank     ||= Money.default_bank

    # BigDecimal can be Infinity and NaN, money of that amount does not make sense
    raise ArgumentError, 'must be initialized with a finite value' unless @fractional.finite?
  end"
Money,dollars,Ret,"",Number,Number,E,Twin,"def dollars
    amount
  end"
Money,amount,Ret,"",Number,Number,E,Twin,"def amount
    to_d
  end"
Money,currency_as_string,Ret,"",String,String,E,Constraints,"def currency_as_string
    warn ""[DEPRECATION] `currency_as_string` is deprecated. Please use `.currency.to_s` instead.""
    currency.to_s
  end"
Money,currency_as_string=,Arg,val,String,String,E,Twin,"def currency_as_string=(val)
    warn ""[DEPRECATION] `currency_as_string=` is deprecated - Money instances are immutable."" \
      "" Please use `with_currency` instead.""
    @currency = Currency.wrap(val)
  end"
Money,currency_as_string=,Ret,"",Money::Currency,Money::Currency,E,Constraints,"def currency_as_string=(val)
    warn ""[DEPRECATION] `currency_as_string=` is deprecated - Money instances are immutable."" \
      "" Please use `with_currency` instead.""
    @currency = Currency.wrap(val)
  end"
Money,hash,Ret,"",Number,Number,E,Constraints,"def hash
    [fractional.hash, currency.hash].hash
  end"
Money,symbol,Ret,"",String,String,E,Constraints,"def symbol
    currency.symbol || ""¤""
  end"
Money,inspect,Ret,"",String,String,E,Constraints,"def inspect
    ""#<#{self.class.name} fractional:#{fractional} currency:#{currency}>""
  end"
Money,to_s,Ret,"",String,String,E,Constraints,"def to_s
    format thousands_separator: '',
           no_cents_if_whole: currency.decimal_places == 0,
           symbol: false,
           ignore_defaults: true
  end"
Money,to_d,Ret,"",{ Money#to_d ret: ret },Number,N,,"def to_d
    as_d(fractional) / as_d(currency.subunit_to_unit)
  end"
Money,to_i,Ret,"",Number,Number,E,Constraints,"def to_i
    to_d.to_i
  end"
Money,to_f,Ret,"",Number,Number,E,Twin,"def to_f
    to_d.to_f
  end"
Money,with_currency,Arg,new_currency,([ !: () -> { { Money#with_currency arg: new_currency }#! call_ret: ret } ] and [ is_a?: (Class) -> { { Money#as_d arg: num }#is_a? call_ret: ret } ] and [ nil?: () -> { { [s]Money::Currency#wrap arg: object }#nil? call_ret: ret } ] and [ respond_to?: (:bank) -> { { Money#initialize arg: obj }#respond_to? call_ret: ret } ] and [ respond_to?: (:currency) -> { { Money#initialize arg: obj }#respond_to? call_ret: ret } ] and [ respond_to?: (:fractional) -> { { Money#initialize arg: obj }#respond_to? call_ret: ret } ] and [ respond_to?: (:to_d) -> { { Money#as_d arg: num }#respond_to? call_ret: ret } ] and [ to_s: () -> String ]),(Money::Currency or String or Symbol),TS,Constraints,"def with_currency(new_currency)
    new_currency = Currency.wrap(new_currency)
    if !new_currency || currency == new_currency
      self
    else
      dup_with(currency: new_currency)
    end
  end"
Money,with_currency,Ret,"",Money,Money,E,Constraints,"def with_currency(new_currency)
    new_currency = Currency.wrap(new_currency)
    if !new_currency || currency == new_currency
      self
    else
      dup_with(currency: new_currency)
    end
  end"
Money,to_money,Ret,"",Money,Money,E,Constraints,"def to_money(given_currency = nil)
    given_currency = Currency.wrap(given_currency)
    if given_currency.nil? || self.currency == given_currency
      self
    else
      exchange_to(given_currency)
    end
  end"
Money,exchange_to,Arg,other_currency,([ is_a?: (Class) -> { { [s]Money::Currency#wrap arg: object }#is_a? call_ret: ret } ] and [ nil?: () -> { { [s]Money::Currency#wrap arg: object }#nil? call_ret: ret } ]),(Money::Currency or String or Symbol),TS,Constraints,"def exchange_to(other_currency, &rounding_method)
    other_currency = Currency.wrap(other_currency)
    if self.currency == other_currency
      self
    else
      @bank.exchange_with(self, other_currency, &rounding_method)
    end
  end"
Money,exchange_to,Ret,"",Money,Money,E,Constraints,"def exchange_to(other_currency, &rounding_method)
    other_currency = Currency.wrap(other_currency)
    if self.currency == other_currency
      self
    else
      @bank.exchange_with(self, other_currency, &rounding_method)
    end
  end"
Money,as_us_dollar,Ret,"",Money,Money,E,Constraints,"def as_us_dollar
    exchange_to(""USD"")
  end"
Money,as_ca_dollar,Ret,"",Money,Money,E,Constraints,"def as_ca_dollar
    exchange_to(""CAD"")
  end"
Money,as_euro,Ret,"",Money,Money,E,Constraints,"def as_euro
    exchange_to(""EUR"")
  end"
Money,allocate,Arg,parts,"([ count: () -> { { [s]Money::Allocation#generate arg: parts }#count call_ret: ret } ] and [ dup: () -> { { [s]Money::Allocation#generate arg: parts }#dup call_ret: ret } ] and [ empty?: () -> { { [s]Money::Allocation#generate arg: parts }#empty? call_ret: ret } ] and [ inject: (Number, :+) -> { { [s]Money::Allocation#generate arg: parts }#inject call_ret: ret } ] and [ is_a?: (Class) -> { { [s]Money::Allocation#generate arg: parts }#is_a? call_ret: ret } ] and [ pop: () -> { { [s]Money::Allocation#generate arg: parts }#pop call_ret: ret } ])",(Array<Number> or Number),TS,Constraints,"def allocate(parts)
    amounts = Money::Allocation.generate(fractional, parts, !Money.default_infinite_precision)
    amounts.map { |amount| dup_with(fractional: amount) }
  end"
Money,allocate,Ret,"",Array<u>,Array<Money>,P,Constraints,"def allocate(parts)
    amounts = Money::Allocation.generate(fractional, parts, !Money.default_infinite_precision)
    amounts.map { |amount| dup_with(fractional: amount) }
  end"
Money,round,Ret,"",Money,Money,E,Constraints,"def round(rounding_mode = self.class.rounding_mode, rounding_precision = 0)
    rounded_amount = as_d(@fractional).round(rounding_precision, rounding_mode)
    dup_with(fractional: rounded_amount)
  end"
Money,format,Arg,rules,*{ Money#format arg: rules },Hash,N,,"def format(*rules)
    Money::Formatter.new(self, *rules).to_s
  end"
Money,format,Ret,"",String,String,E,Constraints,"def format(*rules)
    Money::Formatter.new(self, *rules).to_s
  end"
Money,thousands_separator,Ret,"",String,String,E,Constraints,"def thousands_separator
    (locale_backend && locale_backend.lookup(:thousands_separator, currency)) ||
      Money::Formatter::DEFAULTS[:thousands_separator]
  end"
Money,decimal_mark,Ret,"",String,String,E,Constraints,"def decimal_mark
    (locale_backend && locale_backend.lookup(:decimal_mark, currency)) ||
      Money::Formatter::DEFAULTS[:decimal_mark]
  end"
[s]Money::Bank::Base,instance,Ret,"",Money::Bank::Base,Money::Bank::Base,E,Constraints,"def self.instance
        @singleton ||= self.new
      end"
Money::Bank::Base,initialize,Ret,"",self,self,E,,"def initialize(&block)
        @rounding_method = block
        setup
      end"
Money::Bank::Base,setup,Ret,"",nil,Money::Bank::Base,T,Constraints,"def setup
      end"
Money::Bank::Base,exchange_with,Arg,from,Number,Money,T,Twin,"def exchange_with(from, to_currency, &block)
        raise NotImplementedError, ""#exchange_with must be implemented""
      end"
Money::Bank::Base,exchange_with,Arg,to_currency,Number,(Money::Currency or String or Symbol),T,Twin,"def exchange_with(from, to_currency, &block)
        raise NotImplementedError, ""#exchange_with must be implemented""
      end"
Money::Bank::Base,exchange_with,Ret,"",Money,Money,E,Twin,"def exchange_with(from, to_currency, &block)
        raise NotImplementedError, ""#exchange_with must be implemented""
      end"
Money::Bank::Base,same_currency?,Arg,currency1,([ is_a?: (Class) -> { { [s]Money::Currency#wrap arg: object }#is_a? call_ret: ret } ] and [ nil?: () -> { { [s]Money::Currency#wrap arg: object }#nil? call_ret: ret } ]),(Money::Currency or String or Symbol),TS,Constraints,"def same_currency?(currency1, currency2)
        Currency.wrap(currency1) == Currency.wrap(currency2)
      end"
Money::Bank::Base,same_currency?,Arg,currency2,Number,(Money::Currency or String or Symbol),T,Twin,"def same_currency?(currency1, currency2)
        Currency.wrap(currency1) == Currency.wrap(currency2)
      end"
Money::Bank::Base,same_currency?,Ret,"",(false or true),(false or true),E,Constraints,"def same_currency?(currency1, currency2)
        Currency.wrap(currency1) == Currency.wrap(currency2)
      end"
Money::Bank::VariableExchange,initialize,Arg,st,?Money::RatesStore::Memory,RateStore,T,Constraints,"def initialize(st = Money::RatesStore::Memory.new, &block)
        @store = st
        super(&block)
      end"
Money::Bank::VariableExchange,initialize,Ret,"",self,self,E,,"def initialize(st = Money::RatesStore::Memory.new, &block)
        @store = st
        super(&block)
      end"
Money::Bank::VariableExchange,exchange_with,Arg,from,"(Money and [ dup_with: ({ fractional: { Money::Bank::VariableExchange#exchange ret: ret }, currency: { Money::Bank::VariableExchange#exchange_with arg: to_currency }, bank: Money::Bank::VariableExchange }) -> { { Money::Bank::VariableExchange#exchange_with arg: from }#dup_with call_ret: ret } ] and [ fractional: () -> { { Money::Bank::VariableExchange#calculate_fractional arg: from }#fractional call_ret: ret } ])",Money,TS,Constraints,"def exchange_with(from, to_currency, &block)
        to_currency = Currency.wrap(to_currency)
        if from.currency == to_currency
          from
        else
          if rate = get_rate(from.currency, to_currency)
            fractional = calculate_fractional(from, to_currency)
            from.dup_with(
              fractional: exchange(fractional, rate, &block),
              currency: to_currency,
              bank: self
            )
          else
            raise UnknownRate, ""No conversion rate known for '#{from.currency.iso_code}' -> '#{to_currency}'""
          end
        end
      end"
Money::Bank::VariableExchange,exchange_with,Arg,to_currency,([ is_a?: (Class) -> { { [s]Money::Currency#wrap arg: object }#is_a? call_ret: ret } ] and [ nil?: () -> { { [s]Money::Currency#wrap arg: object }#nil? call_ret: ret } ]),(Money::Currency or String or Symbol),TS,Constraints,"def exchange_with(from, to_currency, &block)
        to_currency = Currency.wrap(to_currency)
        if from.currency == to_currency
          from
        else
          if rate = get_rate(from.currency, to_currency)
            fractional = calculate_fractional(from, to_currency)
            from.dup_with(
              fractional: exchange(fractional, rate, &block),
              currency: to_currency,
              bank: self
            )
          else
            raise UnknownRate, ""No conversion rate known for '#{from.currency.iso_code}' -> '#{to_currency}'""
          end
        end
      end"
Money::Bank::VariableExchange,exchange_with,Ret,"",Money,Money,E,Constraints,"def exchange_with(from, to_currency, &block)
        to_currency = Currency.wrap(to_currency)
        if from.currency == to_currency
          from
        else
          if rate = get_rate(from.currency, to_currency)
            fractional = calculate_fractional(from, to_currency)
            from.dup_with(
              fractional: exchange(fractional, rate, &block),
              currency: to_currency,
              bank: self
            )
          else
            raise UnknownRate, ""No conversion rate known for '#{from.currency.iso_code}' -> '#{to_currency}'""
          end
        end
      end"
Money::Bank::VariableExchange,add_rate,Arg,from,Number,(Money::Currency or String or Symbol),T,Twin,"def add_rate(from, to, rate)
        set_rate(from, to, rate)
      end"
Money::Bank::VariableExchange,add_rate,Arg,to,Number,(Money::Currency or String or Symbol),T,Twin,"def add_rate(from, to, rate)
        set_rate(from, to, rate)
      end"
Money::Bank::VariableExchange,add_rate,Arg,rate,Number,Number,E,Constraints,"def add_rate(from, to, rate)
        set_rate(from, to, rate)
      end"
Money::Bank::VariableExchange,add_rate,Ret,"",Number,Number,E,Twin,"def add_rate(from, to, rate)
        set_rate(from, to, rate)
      end"
Money::Bank::VariableExchange,set_rate,Arg,from,Number,(Money::Currency or String or Symbol),T,Twin,"def set_rate(from, to, rate, opts = {})
        store.add_rate(Currency.wrap(from).iso_code, Currency.wrap(to).iso_code, rate)
      end"
Money::Bank::VariableExchange,set_rate,Arg,to,Number,(Money::Currency or String or Symbol),T,Twin,"def set_rate(from, to, rate, opts = {})
        store.add_rate(Currency.wrap(from).iso_code, Currency.wrap(to).iso_code, rate)
      end"
Money::Bank::VariableExchange,set_rate,Arg,rate,Number,Number,E,Constraints,"def set_rate(from, to, rate, opts = {})
        store.add_rate(Currency.wrap(from).iso_code, Currency.wrap(to).iso_code, rate)
      end"
Money::Bank::VariableExchange,set_rate,Arg,opts,"?Hash<:bank, { Money::RatesStore::Memory#initialize hash_param_val: hash_param_val_#<Parser::Source::Map::Collection:0x00007fd987943a78> }>",Hash,P,Constraints,"def set_rate(from, to, rate, opts = {})
        store.add_rate(Currency.wrap(from).iso_code, Currency.wrap(to).iso_code, rate)
      end"
Money::Bank::VariableExchange,set_rate,Ret,"",Number,Number,E,Twin,"def set_rate(from, to, rate, opts = {})
        store.add_rate(Currency.wrap(from).iso_code, Currency.wrap(to).iso_code, rate)
      end"
Money::Bank::VariableExchange,get_rate,Arg,from,Number,(Money::Currency or String or Symbol),T,Twin,"def get_rate(from, to, opts = {})
        store.get_rate(Currency.wrap(from).iso_code, Currency.wrap(to).iso_code)
      end"
Money::Bank::VariableExchange,get_rate,Arg,to,([ is_a?: (Class) -> { { [s]Money::Currency#wrap arg: object }#is_a? call_ret: ret } ] and [ nil?: () -> { { [s]Money::Currency#wrap arg: object }#nil? call_ret: ret } ]),(Money::Currency or String or Symbol),TS,Constraints,"def get_rate(from, to, opts = {})
        store.get_rate(Currency.wrap(from).iso_code, Currency.wrap(to).iso_code)
      end"
Money::Bank::VariableExchange,get_rate,Arg,opts,"?Hash<:bank, { Money::RatesStore::Memory#initialize hash_param_val: hash_param_val_#<Parser::Source::Map::Collection:0x00007fd987943a78> }>",Hash,P,Constraints,"def get_rate(from, to, opts = {})
        store.get_rate(Currency.wrap(from).iso_code, Currency.wrap(to).iso_code)
      end"
Money::Bank::VariableExchange,get_rate,Ret,"",Number,Number,E,Twin,"def get_rate(from, to, opts = {})
        store.get_rate(Currency.wrap(from).iso_code, Currency.wrap(to).iso_code)
      end"
Money::Bank::VariableExchange,export_rates,Arg,format,String,Symbol,E,Twin,"def export_rates(format, file = nil, opts = {})
        raise Money::Bank::UnknownRateFormat unless RATE_FORMATS.include?(format)

        store.transaction do
          s = RDL.type_cast(FORMAT_SERIALIZERS[format].dump(rates), ""String"")

          unless file.nil?
            File.open(file, ""w"") {|f| f.write(s) }
          end

          s
        end
      end"
Money::Bank::VariableExchange,export_rates,Arg,file,?String,String,E,Constraints,"def export_rates(format, file = nil, opts = {})
        raise Money::Bank::UnknownRateFormat unless RATE_FORMATS.include?(format)

        store.transaction do
          s = RDL.type_cast(FORMAT_SERIALIZERS[format].dump(rates), ""String"")

          unless file.nil?
            File.open(file, ""w"") {|f| f.write(s) }
          end

          s
        end
      end"
Money::Bank::VariableExchange,export_rates,Arg,opts,"?Hash<:bank, { Money::RatesStore::Memory#initialize hash_param_val: hash_param_val_#<Parser::Source::Map::Collection:0x00007fd987943a78> }>",Hash,P,Constraints,"def export_rates(format, file = nil, opts = {})
        raise Money::Bank::UnknownRateFormat unless RATE_FORMATS.include?(format)

        store.transaction do
          s = RDL.type_cast(FORMAT_SERIALIZERS[format].dump(rates), ""String"")

          unless file.nil?
            File.open(file, ""w"") {|f| f.write(s) }
          end

          s
        end
      end"
Money::Bank::VariableExchange,export_rates,Ret,"",Array<u>,String,T,Twin,"def export_rates(format, file = nil, opts = {})
        raise Money::Bank::UnknownRateFormat unless RATE_FORMATS.include?(format)

        store.transaction do
          s = RDL.type_cast(FORMAT_SERIALIZERS[format].dump(rates), ""String"")

          unless file.nil?
            File.open(file, ""w"") {|f| f.write(s) }
          end

          s
        end
      end"
Money::Bank::VariableExchange,import_rates,Arg,format,String,Symbol,E,Twin,"def import_rates(format, s, opts = {})
        raise Money::Bank::UnknownRateFormat unless RATE_FORMATS.include?(format)

        if format == :ruby
          warn '[WARNING] Using :ruby format when importing rates is potentially unsafe and ' \
            'might lead to remote code execution via Marshal.load deserializer. Consider using ' \
            'safe alternatives such as :json and :yaml.'
        end

        store.transaction do
          data = RDL.type_cast(FORMAT_SERIALIZERS[format].load(s), ""Hash<String, Float>"")

          data.each do |key, rate|
            from, to = key.split(SERIALIZER_SEPARATOR)
            store.add_rate from, to, rate
          end
        end

        self
      end"
Money::Bank::VariableExchange,import_rates,Arg,s,String,String,E,Constraints,"def import_rates(format, s, opts = {})
        raise Money::Bank::UnknownRateFormat unless RATE_FORMATS.include?(format)

        if format == :ruby
          warn '[WARNING] Using :ruby format when importing rates is potentially unsafe and ' \
            'might lead to remote code execution via Marshal.load deserializer. Consider using ' \
            'safe alternatives such as :json and :yaml.'
        end

        store.transaction do
          data = RDL.type_cast(FORMAT_SERIALIZERS[format].load(s), ""Hash<String, Float>"")

          data.each do |key, rate|
            from, to = key.split(SERIALIZER_SEPARATOR)
            store.add_rate from, to, rate
          end
        end

        self
      end"
Money::Bank::VariableExchange,import_rates,Arg,opts,"?Hash<:bank, { Money::RatesStore::Memory#initialize hash_param_val: hash_param_val_#<Parser::Source::Map::Collection:0x00007fd987943a78> }>",Hash,P,Constraints,"def import_rates(format, s, opts = {})
        raise Money::Bank::UnknownRateFormat unless RATE_FORMATS.include?(format)

        if format == :ruby
          warn '[WARNING] Using :ruby format when importing rates is potentially unsafe and ' \
            'might lead to remote code execution via Marshal.load deserializer. Consider using ' \
            'safe alternatives such as :json and :yaml.'
        end

        store.transaction do
          data = RDL.type_cast(FORMAT_SERIALIZERS[format].load(s), ""Hash<String, Float>"")

          data.each do |key, rate|
            from, to = key.split(SERIALIZER_SEPARATOR)
            store.add_rate from, to, rate
          end
        end

        self
      end"
Money::Bank::VariableExchange,import_rates,Ret,"",Money::Bank::VariableExchange,Money::Bank::VariableExchange,E,Constraints,"def import_rates(format, s, opts = {})
        raise Money::Bank::UnknownRateFormat unless RATE_FORMATS.include?(format)

        if format == :ruby
          warn '[WARNING] Using :ruby format when importing rates is potentially unsafe and ' \
            'might lead to remote code execution via Marshal.load deserializer. Consider using ' \
            'safe alternatives such as :json and :yaml.'
        end

        store.transaction do
          data = RDL.type_cast(FORMAT_SERIALIZERS[format].load(s), ""Hash<String, Float>"")

          data.each do |key, rate|
            from, to = key.split(SERIALIZER_SEPARATOR)
            store.add_rate from, to, rate
          end
        end

        self
      end"
[s]Money::Currency::Loader,load_currencies,Ret,"",{ [s]Money::Currency::Loader#load_currencies ret: ret },Hash,N,,"def load_currencies
          currencies = parse_currency_file(""currency_iso.json"")
          currencies.merge! parse_currency_file(""currency_non_iso.json"")
          currencies.merge! parse_currency_file(""currency_backwards_compatible.json"")
        end"
Money::LocaleBackend::I18n,initialize,Ret,"",self,self,E,,"def initialize
        raise NotSupported, 'I18n not found' unless defined?(::I18n)
      end"
Money::LocaleBackend::Legacy,initialize,Ret,"",self,self,E,,"def initialize
        raise NotSupported, 'I18n not found' if Money.use_i18n && !defined?(::I18n)
      end"
Money::Arithmetic,-@,Ret,"",Money,Money,E,Constraints,"def -@
      dup_with(fractional: -fractional)
    end"
Money::Arithmetic,eql?,Arg,other_money,([ currency: () -> { { Money::Arithmetic#eql? arg: other_money }#currency call_ret: ret } ] and [ fractional: () -> { { Money::Arithmetic#eql? arg: other_money }#fractional call_ret: ret } ] and [ is_a?: (Class) -> { { Money::Arithmetic#eql? arg: other_money }#is_a? call_ret: ret } ]),Money,TS,Constraints,"def eql?(other_money)
      if other_money.is_a?(Money)
        (fractional == other_money.fractional && currency == other_money.currency) ||
          (fractional == 0 && other_money.fractional == 0)
      else
        false
      end
    end"
Money::Arithmetic,eql?,Ret,"",(false or true),(false or true),E,Constraints,"def eql?(other_money)
      if other_money.is_a?(Money)
        (fractional == other_money.fractional && currency == other_money.currency) ||
          (fractional == 0 && other_money.fractional == 0)
      else
        false
      end
    end"
Money::Arithmetic,<=>,Arg,other,([ exchange_to: ({ Money#currency ret: ret }) -> { { Money::Arithmetic#<=> arg: other }#exchange_to call_ret: ret } ] and [ fractional: () -> { { Money::Arithmetic#<=> arg: other }#fractional call_ret: ret } ] and [ is_a?: (Class) -> { { Money::Arithmetic#<=> arg: other }#is_a? call_ret: ret } ] and [ respond_to?: (:zero?) -> { { Money::Arithmetic#<=> arg: other }#respond_to? call_ret: ret } ] and [ zero?: () -> { { Money::Arithmetic#<=> arg: other }#zero? call_ret: ret } ]),Money,TS,Constraints,"def <=>(other)
      unless other.is_a?(Money)
        return unless other.respond_to?(:zero?) && other.zero?
        return other.is_a?(CoercedNumeric) ? 0 <=> fractional : fractional <=> 0
      end

      # Always allow comparison with zero
      if zero? || other.zero?
        return fractional <=> other.fractional
      end

      other = other.exchange_to(currency)
      fractional <=> other.fractional
    rescue Money::Bank::UnknownRate
    end"
Money::Arithmetic,<=>,Ret,"",Number,Number,E,Constraints,"def <=>(other)
      unless other.is_a?(Money)
        return unless other.respond_to?(:zero?) && other.zero?
        return other.is_a?(CoercedNumeric) ? 0 <=> fractional : fractional <=> 0
      end

      # Always allow comparison with zero
      if zero? || other.zero?
        return fractional <=> other.fractional
      end

      other = other.exchange_to(currency)
      fractional <=> other.fractional
    rescue Money::Bank::UnknownRate
    end"
Money::Arithmetic,positive?,Ret,"",(false or true),(false or true),E,Constraints,"def positive?
      fractional > 0
    end"
Money::Arithmetic,negative?,Ret,"",(false or true),(false or true),E,Constraints,"def negative?
      fractional < 0
    end"
Money::Arithmetic,*,Arg,value,(Number and [ value: () -> { { Money::Arithmetic#* arg: value }#value call_ret: ret } ]),Number,TS,Constraints,"def *(value)
      value = value.value if value.is_a?(CoercedNumeric)
      if value.is_a? Numeric
        dup_with(fractional: fractional * value)
      else
        raise TypeError, ""Can't multiply a #{self.class.name} by a #{value.class.name}'s value""
      end
    end"
Money::Arithmetic,*,Ret,"",Money,Money,E,Constraints,"def *(value)
      value = value.value if value.is_a?(CoercedNumeric)
      if value.is_a? Numeric
        dup_with(fractional: fractional * value)
      else
        raise TypeError, ""Can't multiply a #{self.class.name} by a #{value.class.name}'s value""
      end
    end"
Money::Arithmetic,/,Arg,value,([ exchange_to: ({ Money#currency ret: ret }) -> { { Money::Arithmetic#/ arg: value }#exchange_to call_ret: ret } ] and [ is_a?: (Module) -> { { Money::Arithmetic#/ arg: value }#is_a? call_ret: ret } ] and [ respond_to?: (:to_d) -> { { Money#as_d arg: num }#respond_to? call_ret: ret } ] and [ to_s: () -> String ]),(Money or Number),TS,Constraints,"def /(value)
      if value.is_a?(self.class)
        fractional / as_d(value.exchange_to(currency).fractional).to_f
      else
        raise TypeError, 'Can not divide by Money' if value.is_a?(CoercedNumeric)
        dup_with(fractional: fractional / as_d(value))
      end
    end"
Money::Arithmetic,div,Arg,value,([ exchange_to: ({ Money#currency ret: ret }) -> { { Money::Arithmetic#/ arg: value }#exchange_to call_ret: ret } ] and [ is_a?: (Module) -> { { Money::Arithmetic#/ arg: value }#is_a? call_ret: ret } ] and [ respond_to?: (:to_d) -> { { Money#as_d arg: num }#respond_to? call_ret: ret } ] and [ to_s: () -> String ]),(Money or Number),TS,Constraints,"def div(value)
      self / value
    end"
Money::Arithmetic,divmod,Arg,val,(String and [ exchange_to: ({ Money#currency ret: ret }) -> { { Money::Arithmetic#divmod_money arg: val }#exchange_to call_ret: ret } ] and [ respond_to?: (:to_d) -> { { Money#as_d arg: num }#respond_to? call_ret: ret } ] and [ to_s: () -> String ]),(Money or Number),TS,Constraints,"def divmod(val)
      if val.is_a?(Money)
        divmod_money(val)
      else
        divmod_other(val)
      end
    end"
Money::Arithmetic,divmod,Ret,"","[Money, Money]",(Array<(Money or Number)> or Array<Money>),P,Constraints,"def divmod(val)
      if val.is_a?(Money)
        divmod_money(val)
      else
        divmod_other(val)
      end
    end"
Money::Arithmetic,modulo,Arg,val,(String and [ exchange_to: ({ Money#currency ret: ret }) -> { { Money::Arithmetic#divmod_money arg: val }#exchange_to call_ret: ret } ] and [ respond_to?: (:to_d) -> { { Money#as_d arg: num }#respond_to? call_ret: ret } ] and [ to_s: () -> String ]),(Money or Number),TS,Constraints,"def modulo(val)
      divmod(val)[1]
    end"
Money::Arithmetic,modulo,Ret,"",Money,Money,E,Constraints,"def modulo(val)
      divmod(val)[1]
    end"
Money::Arithmetic,%,Arg,val,(String and [ exchange_to: ({ Money#currency ret: ret }) -> { { Money::Arithmetic#divmod_money arg: val }#exchange_to call_ret: ret } ] and [ respond_to?: (:to_d) -> { { Money#as_d arg: num }#respond_to? call_ret: ret } ] and [ to_s: () -> String ]),(Money or Number),TS,Constraints,"def %(val)
      modulo(val)
    end"
Money::Arithmetic,%,Ret,"",Money,Money,E,Constraints,"def %(val)
      modulo(val)
    end"
Money::Arithmetic,remainder,Arg,val,(String and [ currency: () -> { { Money::Arithmetic#remainder arg: val }#currency call_ret: ret } ] and [ exchange_to: ({ Money#currency ret: ret }) -> { { Money::Arithmetic#divmod_money arg: val }#exchange_to call_ret: ret } ] and [ is_a?: (Class) -> { { Money#as_d arg: num }#is_a? call_ret: ret } ] and [ nil?: () -> { { [s]Money::Currency#wrap arg: object }#nil? call_ret: ret } ] and [ respond_to?: (:bank) -> { { Money#initialize arg: obj }#respond_to? call_ret: ret } ] and [ respond_to?: (:currency) -> { { Money#initialize arg: obj }#respond_to? call_ret: ret } ] and [ respond_to?: (:fractional) -> { { Money#initialize arg: obj }#respond_to? call_ret: ret } ] and [ respond_to?: (:to_d) -> { { Money#as_d arg: num }#respond_to? call_ret: ret } ] and [ to_s: () -> String ]),(Money or Number),TS,Constraints,"def remainder(val)
      if val.is_a?(Money) && currency != val.currency
        val = val.exchange_to(currency)
      end

      if (fractional < 0 && val < 0) || (fractional > 0 && val > 0)
        self.modulo(val)
      else
        self.modulo(val) - (val.is_a?(Money) ? val : dup_with(fractional: val))
      end
    end"
Money::Arithmetic,remainder,Ret,"",Money,Money,E,Constraints,"def remainder(val)
      if val.is_a?(Money) && currency != val.currency
        val = val.exchange_to(currency)
      end

      if (fractional < 0 && val < 0) || (fractional > 0 && val > 0)
        self.modulo(val)
      else
        self.modulo(val) - (val.is_a?(Money) ? val : dup_with(fractional: val))
      end
    end"
Money::Arithmetic,abs,Ret,"",Money,Money,E,Constraints,"def abs
      dup_with(fractional: fractional.abs)
    end"
Money::Arithmetic,zero?,Ret,"",(false or true),(false or true),E,Constraints,"def zero?
      fractional == 0
    end"
Money::Arithmetic,nonzero?,Ret,"",Money::Arithmetic,Money,T,Constraints,"def nonzero?
      fractional != 0 ? self : nil
    end"
Money::Arithmetic,coerce,Ret,"","[Money::Arithmetic, { [s]Money::Arithmetic::CoercedNumeric#new ret: ret }]",Array,P,Constraints,"def coerce(other)
      [self, CoercedNumeric.new(other)]
    end"
Money::Formatter,show_free_text?,Ret,"",(false or true),(false or true),E,Twin,"def show_free_text?
      money.zero? && rules[:display_free]
    end"
Money::RatesStore::Memory,initialize,Arg,opts,"?Hash<:bank, { Money::RatesStore::Memory#initialize hash_param_val: hash_param_val_#<Parser::Source::Map::Collection:0x00007fd987943a78> }>",Hash,P,Constraints,"def initialize(opts = {}, rates = {})
        @rates = rates
        @options = opts
        @guard = Monitor.new
      end"
Money::RatesStore::Memory,initialize,Arg,rates,"?Hash<{ Money::RatesStore::Memory#initialize hash_param_key: hash_param_key_#<Parser::Source::Map::Collection:0x00007fd987943258> }, { Money::RatesStore::Memory#initialize hash_param_val: hash_param_val_#<Parser::Source::Map::Collection:0x00007fd987943258> }>",Hash,P,Constraints,"def initialize(opts = {}, rates = {})
        @rates = rates
        @options = opts
        @guard = Monitor.new
      end"
Money::RatesStore::Memory,initialize,Ret,"",self,self,E,,"def initialize(opts = {}, rates = {})
        @rates = rates
        @options = opts
        @guard = Monitor.new
      end"
Money::RatesStore::Memory,add_rate,Arg,currency_iso_from,{ Money::RatesStore::Memory#add_rate arg: currency_iso_from },String,N,,"def add_rate(currency_iso_from, currency_iso_to, rate)
        guard.synchronize do
          RDL.type_cast(rates, ""Hash<String, Integer>"")[rate_key_for(currency_iso_from, currency_iso_to)] = rate
        end
      end"
Money::RatesStore::Memory,add_rate,Arg,currency_iso_to,{ Money::RatesStore::Memory#add_rate arg: currency_iso_to },String,N,,"def add_rate(currency_iso_from, currency_iso_to, rate)
        guard.synchronize do
          RDL.type_cast(rates, ""Hash<String, Integer>"")[rate_key_for(currency_iso_from, currency_iso_to)] = rate
        end
      end"
Money::RatesStore::Memory,add_rate,Arg,rate,Number,Number,E,Constraints,"def add_rate(currency_iso_from, currency_iso_to, rate)
        guard.synchronize do
          RDL.type_cast(rates, ""Hash<String, Integer>"")[rate_key_for(currency_iso_from, currency_iso_to)] = rate
        end
      end"
Money::RatesStore::Memory,add_rate,Ret,"",{ Money::RatesStore::Memory#add_rate ret: ret },Number,N,,"def add_rate(currency_iso_from, currency_iso_to, rate)
        guard.synchronize do
          RDL.type_cast(rates, ""Hash<String, Integer>"")[rate_key_for(currency_iso_from, currency_iso_to)] = rate
        end
      end"
Money::RatesStore::Memory,get_rate,Arg,currency_iso_from,Number,String,T,Twin,"def get_rate(currency_iso_from, currency_iso_to)
        guard.synchronize do
          rates[rate_key_for(currency_iso_from, currency_iso_to)]
        end
      end"
Money::RatesStore::Memory,get_rate,Arg,currency_iso_to,Number,String,T,Twin,"def get_rate(currency_iso_from, currency_iso_to)
        guard.synchronize do
          rates[rate_key_for(currency_iso_from, currency_iso_to)]
        end
      end"
Money::RatesStore::Memory,get_rate,Ret,"",{ Money::RatesStore::Memory#get_rate ret: ret },Number,N,,"def get_rate(currency_iso_from, currency_iso_to)
        guard.synchronize do
          rates[rate_key_for(currency_iso_from, currency_iso_to)]
        end
      end"
Money::RatesStore::Memory,each_rate,Ret,"",Enumerator<%any>,Enumerator,P,Constraints,"def each_rate(&block)
        return to_enum(:each_rate) unless block_given?

        guard.synchronize do
          rates.each do |key, rate|
            iso_from, iso_to = key.split(INDEX_KEY_SEPARATOR)
            yield iso_from, iso_to, rate
          end
        end
      end"
Money::RatesStore::Memory,rate_key_for,Arg,currency_iso_from,{ Money::RatesStore::Memory#rate_key_for arg: currency_iso_from },String,N,,"def rate_key_for(currency_iso_from, currency_iso_to)
        [currency_iso_from, currency_iso_to].join(INDEX_KEY_SEPARATOR).upcase
      end"
Money::RatesStore::Memory,rate_key_for,Arg,currency_iso_to,{ Money::RatesStore::Memory#rate_key_for arg: currency_iso_to },String,N,,"def rate_key_for(currency_iso_from, currency_iso_to)
        [currency_iso_from, currency_iso_to].join(INDEX_KEY_SEPARATOR).upcase
      end"
Money::RatesStore::Memory,rate_key_for,Ret,"",String,String,E,Constraints,"def rate_key_for(currency_iso_from, currency_iso_to)
        [currency_iso_from, currency_iso_to].join(INDEX_KEY_SEPARATOR).upcase
      end"
Total # E:,73
Total # P:,11
Total # T:,22
Total # TS:,30
Total # N:,16
Total # return types:,83
Total # arg types:,69
Total # var types:,0
Total # individual types:,210
